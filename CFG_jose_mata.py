#This is Jose Mata's submission for COMP 540 - Automata's CFG Project. Fall 2024, Bridgewater State University

import random

#Create the data structure - a dictionary of lists - for the grammar in the CFG Project Instructions
grammar1 = {
    'S' : ['AB', 'aS'],
    'A' : ['aA', 'b'], 
    'B' : ['bB', 'a']
    }

start_symbol = 'S'

def generate_random_string(word, variable):
    list_of_sets = grammar1[variable]
    chosen_set = list_of_sets[random.randint(0,len(list_of_sets)-1)]
    #print(chosen_set+'\n')
    for char in chosen_set:
        if char.isupper():
            word = generate_random_string(word, char)
        else:
            word = word + char
    if word.islower():
        return word

def change_grammar(grammar1):
    grammar1['S'] = get_and_check_sets(grammar1, 'S')
    grammar1['A'] = get_and_check_sets(grammar1, 'A')
    grammar1['B'] = get_and_check_sets(grammar1, 'B')
    return grammar1

def get_and_check_sets(grammar1, letter):
    values_of_letter_str = input("Enter the sets of characters that " + letter + " can be replaced by, each set separated by a space. Do not use quotation marks of any kind.\n")
    values_of_letter =  values_of_letter_str.split()
    #check that the list is not empty
    if len(values_of_letter) == 0:
        print("This set cannot be left empty. The grammar rules for " + letter + " were not changed.")
        return grammar1[letter]
    #check for no invalid characters
    for set in values_of_letter:
        for char in set:
            if char not in ['S', 'A', 'B', 'a', 'b']:
                print("One of more of your sets was invalid. The grammar rules for " + letter + " were not changed.")
                return grammar1[letter]
    return values_of_letter

#The recursive function check_str below was not finalized but it is meant to perform a brute force approach to try the
#transitions that will lead to the word input by the user. I suspect that I was on the right path here but a few changes 
#need to be made for the function to work
def check_str(word_to_check, start_symbol, grammar1, word_created, current_symbol, first_time, index):
    if first_time == 1:
        symbol = start_symbol
        letter_index = 0
    else: 
        symbol = current_symbol
        letter_index = index
    direct_transformation = 0
    indirect_transformation = 0
    for value in grammar1[symbol]:
        for value_char in value:
            if value_char == word_to_check[letter_index]:
                word_created = word_created + word_to_check[letter_index]
                print("There was a direct transformation.")
                direct_transformation = 1
                letter_index = letter_index + 1
                return word_created
                
    if direct_transformation == 0:
         print("No direct transformation was possible")
         for value in grammar1[symbol]: 
             for value_char in value: 
                 if grammar1[value_char]:
                    for indirect_value in grammar1[value_char]:
                        for indirect_value_char in indirect_value:
                            word_created = check_str(word_to_check, indirect_value_char, grammar1, word_created, indirect_value_char, 0, letter_index)
    print("word created is: " + word_created)


while True: 
    answer = input("This is Jose Mata's CFG Project. Please enter:\n'1' to produce a random string from the CFG shown in the assignment instructions.\n'2' to display the production rules of this grammar.\n'3' to check if a string can be generated by the grammar.\n'4' to change the grammar.\n'5' to exit the pogram.\n")
    if answer == '1':
        empty_word = ''
        random_word = generate_random_string(empty_word, start_symbol)
        print("The random word generated by this grammar is: " + random_word + "\n")
    elif answer == '2':
        print("The following are the production rules of this grammar:")
        for key, value in grammar1.items():
            print(key + ' : ' + str(value))
        print("Start symbol: " + start_symbol + "\n")
    elif answer == '3': 
        word_to_check = input("Enter the word you'd like to check to see if it is a word that can be produced by this grammar.")
        #Call the check_str function. This function was not finalized but it is meant to perform a brute-force approach to try the
        #transitions that will lead to the word input by the user. 
        word_found = check_str(word_to_check, start_symbol, grammar1, '', start_symbol, 1, 0)
    elif answer ==  '4':
        print("You're now going to change the grammar rules. Please remember that the grammar must only have the characters 'S', 'A', 'B', 'a', and/or 'b' and that it must allow for the eventual conversion to only terminals:")
        grammar1 = change_grammar(grammar1)
    elif answer == '5':
        print("Exiting the program...\n")
        break
    else:
        print("Answer is invalid.\n")
